#!/usr/bin/php
<?
declare(ticks = 1);
include_once('include/system.inc.php');

class filestored  {

	protected $oFileserver = NULL;

	protected $oAunSocket = NULL;
	
	protected $aAllReadableSockets = array();

	function main()
	{
		$aOpts = getopt("dp:");
		$bDaemonize = FALSE;
		$sPidFile = "";

		foreach($aOpts AS $sOpt => $sValue){
			switch($sOpt){
				case "d":
					$bDaemonize = TRUE;
					break;
				case "p":
					$sPidFile = $sValue;
					break;
			}
		}

		if($bDaemonize){
			$this->daemonize($sPidFile);
		}
		//Setup signle handler
		pcntl_signal(SIGCHLD,array($this,'sigHandler'));
		pcntl_signal(SIGALRM, array($this, 'sigHandler'));
		pcntl_signal(SIGTERM,array($this,'sigHandler'));
		$this->registerNextAlarm();

		//Create a file server instance and start it
		$this->oFileserver = new fileserver($this);
		$this->oFileserver->init();

		//Load the aunmap that maps econet network/station numbers to ip addresses and ports
		aunmap::loadMap();
		
		//Setup listening sockets
		$this->bindSockets();

		//Enter main loop
		$this->loop();
	}

	public function sigHandler($iSigno)
	{
		switch($iSigno){
			case SIGALRM:
				//On sigalarm perform any house keeping tasks
				logger::log("Got sig alarm",LOG_DEBUG);
				security::houseKeeping();
				vfs::houseKeeping();
				$this->registerNextAlarm();
				break;
			case SIGTERM:
				logger::log("Shutting down filestored",LOG_INFO);
				break;
			case SIGCHLD:
			default:
				//Ignore
				break;
		}
	}

	protected function registerNextAlarm()
	{
		pcntl_alarm(config::getValue('housekeeping_interval'));
	}


	/**
	 * Cause the program to daemonize 
	 *
	 * The current pid starts a child (that continues and becomes the running server) while the parent pid exits
	 *
	 * @param string $sPidFile The file to write the pid of the child to
	*/
	function daemonize($sPidFile)
	{
		$iPid=pcntl_fork();
		if($iPid != 0){
			//We are the parent 
			if($sPidFile!=""){
				//Write the child pid to the pid file
				file_put_contents($sPidFile,$iPid);
			}
			exit(0);
		}else{
			//We are the child close stdin,stdout,stderr
			fclose(STDIN);
			fclose(STDOUT);
			fclose(STDERR);
		}
	}

	/**
	 * Sets up a UDP sockets listening on the port used for aun packets 
	 *
	*/	
	function bindSockets()
	{
		$this->oAunSocket = stream_socket_server('udp://'.config::getValue('aun_listen_address').':'.config::getValue('aun_listen_port'),$iErrno,$sErrstr,STREAM_SERVER_BIND);
		if($this->oAunSocket===FALSE){
			throw new Exception("Un-able to bind AUN socket (".$sErrstr.")",$iErrno);
		}
		$this->aAllReadableSockets=array($this->oAunSocket);
	}

	/**
	 * The main code loop
	 *
	 * Reads any aun packets, decodes them, acks them, sends them to the fileserver class (if they are file server packets) and dispatches any replys
	*/
	function loop()
	{

		$sErrstr=NULL;
		$iErrno=NULL;
		$bLoop=TRUE;
		$aWriteSet=NULL;
		$aAllExpSockets=array(NULL);

		//Main Loop
		while($bLoop){
			$aReadSet=$this->aAllReadableSockets;
			$aExpSet=$aAllExpSockets;
			$iSockets = @stream_select($aReadSet,$aWriteSet,$aExpSet,NULL);
			if($iSockets!==FALSE){
				//Step through each socket we need to read from
				foreach($aReadSet as  $iReadSocket){
					if($iReadSocket == $this->oAunSocket){
						//We've received an AUN packet process it 
						$this->processAunPacket($this->oAunSocket);
					}
				}
			}
		}


	}
	

	/**
	 * This method reads a aun packet sends any acks (if needed)
	 * and passes the resulting econet packet to processEconetPacket
	 *
	 * @param int $oSocket The socket to read the aun packet from
	*/
	public function processAunPacket($oSocket)
	{
		//Read the UDP data
		$sUdpData= stream_socket_recvfrom($oSocket,1500,0,$sHost);
		logger::log("filestore: Aun packet recvieved from ".$sHost,LOG_DEBUG);	

		//Decode the AUN packet
		$oAunPacket = new AunPacket();
		$oAunPacket->setSourceIP($sHost);
		$oAunPacket->setDestinationIP(config::getValue('local_ip'));
		$oAunPacket->decode($sUdpData);
		
		//Send an ack for the AUN packet if needed
		$sAck = $oAunPacket->buildAck();
		if(strlen($sAck)>0){
			logger::log("filestore: Sending Ack packet",LOG_DEBUG);
			stream_socket_sendto($oSocket,$sAck,0,$sHost);
		}
	
		//Build an econet packet from the AUN packet an pass it to be processed
		if($oAunPacket->getPacketType()=='Unicast'){
			$oEconetPacket = $oAunPacket->buildEconetPacket();
			$this->processEconetPacket($oEconetPacket);
		}elseif($oAunPacket->getPacketType()=='Broadcast'){
			logger::log("filestore: Received broadcast packet ",LOG_DEBUG);
			if($oAunPacket->getPortName()=='Bridge'){
				$aPkt = unpack('C*',$oAunPacket->getData());
				logger::log("filestore: Bridge packet received (".implode(":",$aPkt).")",LOG_DEBUG);
			}
		}

	}

	/**
	 * Read the econet packet and passes it to the class to deal with that type of packet
	 *
	 * Only the file server is implemented at the moment so only file server packets are processed 
	*/
	public function processEconetPacket($oEconetPacket)
	{
	
		$sPort = $oEconetPacket->getPortName();
		switch($sPort){
			case 'FileServerCommand':
				$this->fileServerCommand($oEconetPacket);
				break;
			default:
				logger::log("filestore: Recived packet on un-handle port (".$sPort.")".$sPort,LOG_DEBUG);
				break;
		}

	}

	/**
	 * Deals with a econet packet on the file server port
	 *
	 * It build an fsrequest from the econet packet and dispatches it to the fileserver class to be dealt with
	 * Any reply packets produced by the file server class at this point are dispatched	
	 * @param object econetpacket $oEconetPacket
	*/
	public function fileServerCommand($oEconetPacket)
	{
		$oFsRequest = new fsrequest($oEconetPacket);
		$this->oFileserver->processRequest($oFsRequest);
		$aReplies = $this->oFileserver->getReplies();
		foreach($aReplies as $oReply){
			logger::log("filestore: Sending econet reply");
			$oReplyEconetPacket = $oReply->buildEconetpacket();
			$this->dispatchReply($oReplyEconetPacket);	
		}
	}

	/**
	 * Sends a replay packet to a remote machine
	 *
	 * @param object econetpacket $oReplyEconetPacket
	*/
	public function dispatchReply($oReplyEconetPacket)
	{
		usleep(config::getValue('bbc_default_pkg_sleep'));
		$sIP = aunmap::ecoAddrToIpAddr($oReplyEconetPacket->getDestinationNetwork(),$oReplyEconetPacket->getDestinationStation());
		if(strlen($sIP)>0){
			$sPacket = $oReplyEconetPacket->getAunFrame();
			logger::log("filestore: AUN packet to ".$sIP." (".implode(':',unpack('C*',$sPacket)).")",LOG_DEBUG);
			if(strlen($sPacket)>0){
				if(strpos($sIP,':')===FALSE){
					$sHost=$sIP.':'.config::getValue('aun_default_port');
				}else{
					$sHost=$sIP;
				}
				stream_socket_sendto($this->oAunSocket,$sPacket,0,$sHost);
			}
		}
	}

	/**
	 * This method is to allow for the file server to break out of the main loop breifly and
	 * accept a direct stream from the client
	 *
	 * @param int $iPort the econet port to accept the stream on
	*/
	public function directStream($iNetwork,$iStation,$iPort,$iRecursion=0)
	{
		if($iRecursion>20){
			throw new Exception("No direct stream recevied in 20 packets");
		}
		$aReadSet=$this->aAllReadableSockets;
		$aWriteSet=NULL;
		$aAllExpSockets=array(NULL);
		$aExpSet=$aAllExpSockets;

		//Wait for an aun packet
		$iSockets = @stream_select($aReadSet,$aWriteSet,$aExpSet,4);
		if($iSockets!=FALSE){
			//Step through each socket we need to read from
			foreach($aReadSet as  $iReadSocket){
				if($iReadSocket == $this->oAunSocket){
					//We've received an AUN packet process it 
					$sUdpData= stream_socket_recvfrom($this->oAunSocket,1500,0,$sHost);
					logger::log("filestore: Aun packet recvieved from ".$sHost,LOG_DEBUG);	
					//Decode the AUN packet
					$oAunPacket = new AunPacket();
					$oAunPacket->setSourceIP($sHost);
					$oAunPacket->setDestinationIP(config::getValue('local_ip'));
					$oAunPacket->decode($sUdpData);
					
					//Send an ack for the AUN packet if needed
					$sAck = $oAunPacket->buildAck();
					if(strlen($sAck)>0){
						logger::log("filestore: Sending Ack packet",LOG_DEBUG);
						stream_socket_sendto($this->oAunSocket,$sAck,0,$sHost);
					}
				
					//Build an econet packet from the AUN packet and see if it's the direct stream we are waiting for 
					if($oAunPacket->getPacketType()=='Unicast'){
						$oEconetPacket = $oAunPacket->buildEconetPacket();
						if($oEconetPacket->getSourceNetwork()==$iNetwork AND $oEconetPacket->getSourceStation()==$iStation AND $oEconetPacket->getPort()==$iPort){
							//It's the frame we are waiting for.
							return $oEconetPacket;
						}else{
							//Not the direct data stream we are waiting for but the packet must be processed in the normal way
							$this->processEconetPacket($oEconetPacket);
							//Go back to listening for the direct stream
							return $this->directStream($iNetwork,$iStation,$iPort,$iRecursion+1);
						}
					}else{
						return $this->directStream($iNetwork,$iStation,$iPort,$iRecursion+1);
					}
				}
			}
		
		}else{
			throw new Exception("Direct stream timeout");
		}
	}

	/**
	 * This method keaps waiting for an ack from a given econet address
	 *
	 * If a none ack packet arrives while waiting for an ack that packet is processed
	 *
	 * @param int $iNetwork
	 * @param int $iStation
	 * @param int $iRecursion
	*/
	public function waitForAck($iNetwork,$iStation,$iRecursion=0)
	{
		if($iRecursion>20){
			throw new Exception("No ack recevied in 20 packets");
		}

		$aReadSet=$this->aAllReadableSockets;
		$aWriteSet=NULL;
		$aAllExpSockets=array(NULL);
		$aExpSet=$aAllExpSockets;

		//Wait for an aun packet
		$iSockets = @stream_select($aReadSet,$aWriteSet,$aExpSet,1);
		if($iSockets!=FALSE){
			//Step through each socket we need to read from
			foreach($aReadSet as  $iReadSocket){
				if($iReadSocket == $this->oAunSocket){
					//We've received an AUN packet process it 
					$sUdpData= stream_socket_recvfrom($this->oAunSocket,1500,0,$sHost);
					logger::log("filestore: Aun packet recvieved from ".$sHost,LOG_DEBUG);	

					//Decode the AUN packet
					$oAunPacket = new AunPacket();
					$oAunPacket->setSourceIP($sHost);
					$oAunPacket->setDestinationIP(config::getValue('local_ip'));
					$oAunPacket->decode($sUdpData);
					
					//Send an ack for the AUN packet if needed
					$sAck = $oAunPacket->buildAck();
					if(strlen($sAck)>0){
						logger::log("filestore: Sending Ack packet",LOG_DEBUG);
						stream_socket_sendto($this->oAunSocket,$sAck,0,$sHost);
					}
				
					//Build an econet packet from the AUN packet and see if it's the direct stream we are waiting for 
					if($oAunPacket->getPacketType()=='Ack'){
						$oEconetPacket = $oAunPacket->buildEconetPacket();
						if($oEconetPacket->getSourceNetwork()==$iNetwork AND $oEconetPacket->getSourceStation()==$iStation){
							//It's the frame we are waiting for.
							return $oEconetPacket;
						}else{
							//Not the direct data stream we are waiting for but the packet must be processed in the normal way
							$this->processEconetPacket();
							//Go back to listening for the direct stream
							return $this->waitForAck($iNetwork,$iStation,$iRecursion+1);
						}
					}else{
						return $this->waitForAck($iNetwork,$iStation,$iRecursion+1);
					}
				}
			}
		
		}else{
			throw new Exception("Waiting for ack timeout");
		}

	}
}

$oApp = new filestored();
$oApp->main();
?>
